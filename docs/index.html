<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>極限打磚塊 - 完整合成版</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            background: radial-gradient(circle, #1a1a2e 0%, #16213e 100%); 
            color: #fff; 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            justify-content: center; 
            height: 100vh; 
            overflow: hidden; 
        }
        #ui-layer {
            margin-bottom: 15px;
            display: flex;
            gap: 30px;
            font-size: 20px;
            text-shadow: 0 0 10px #00d4ff;
        }
        #game-container {
            position: relative;
            border: 5px solid #0f3460;
            border-radius: 10px;
            box-shadow: 0 0 30px rgba(0, 212, 255, 0.3);
            background: #000;
        }
        canvas { display: block; cursor: none; }
        #overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            border-radius: 5px;
            z-index: 10;
        }
        button {
            background: #e94560;
            color: white;
            border: none;
            padding: 12px 30px;
            font-size: 18px;
            border-radius: 25px;
            cursor: pointer;
            transition: 0.3s;
            margin-top: 15px;
        }
        button:hover { background: #ff2e63; transform: scale(1.1); }
        .hidden { display: none !important; }
    </style>
</head>
<body>

<div id="ui-layer">
    <div>分數: <span id="score">0</span></div>
    <div>生命: <span id="lives">3</span></div>
    <div>關卡: <span id="level">1</span></div>
</div>

<div id="game-container">
    <canvas id="gameCanvas" width="640" height="480"></canvas>
    
    <div id="overlay">
        <h1 id="status-title">打磚塊遊戲</h1>
        <p id="status-desc">移動滑鼠來控制擋板</p>
        <button id="start-btn" onclick="startGame()">開始遊戲</button>
    </div>
</div>

<script>
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    const scoreEl = document.getElementById("score");
    const livesEl = document.getElementById("lives");
    const levelEl = document.getElementById("level");
    const overlay = document.getElementById("overlay");
    const statusTitle = document.getElementById("status-title");

    // 遊戲參數
    let score = 0;
    let lives = 3;
    let level = 1;
    let isRunning = false;

    // 擋板
    let paddleHeight = 12;
    let paddleWidth = 100;
    let paddleX = (canvas.width - paddleWidth) / 2;

    // 球
    let ballRadius = 8;
    let x, y, dx, dy;

    // 磚塊
    const brickColumnCount = 8;
    let brickRowCount = 3;
    const brickWidth = 65;
    const brickHeight = 20;
    const brickPadding = 10;
    const brickOffsetTop = 50;
    const brickOffsetLeft = 25;
    let bricks = [];

    // 道具系統
    let powerUps = [];

    function initGameValues() {
        x = canvas.width / 2;
        y = canvas.height - 30;
        dx = 4 + level;
        dy = -(4 + level);
        paddleWidth = 100;
        initBricks();
    }

    function initBricks() {
        bricks = [];
        for(let c=0; c<brickColumnCount; c++) {
            bricks[c] = [];
            for(let r=0; r<brickRowCount; r++) {
                // 10% 機率產生含有道具的磚塊
                let type = Math.random() > 0.9 ? "longPaddle" : "normal";
                bricks[c][r] = { x: 0, y: 0, status: 1, type: type };
            }
        }
    }

    document.addEventListener("mousemove", (e) => {
        let rect = canvas.getBoundingClientRect();
        let relativeX = e.clientX - rect.left;
        if(relativeX > 0 && relativeX < canvas.width) {
            paddleX = relativeX - paddleWidth / 2;
        }
    });

    function startGame() {
        score = 0;
        lives = 3;
        level = 1;
        brickRowCount = 3;
        scoreEl.innerText = score;
        livesEl.innerText = lives;
        levelEl.innerText = level;
        overlay.classList.add("hidden");
        initGameValues();
        isRunning = true;
        powerUps = [];
        draw();
    }

    function collisionDetection() {
        for(let c=0; c<brickColumnCount; c++) {
            for(let r=0; r<brickRowCount; r++) {
                let b = bricks[c][r];
                if(b.status === 1) {
                    if(x > b.x && x < b.x + brickWidth && y > b.y && y < b.y + brickHeight) {
                        dy = -dy;
                        b.status = 0;
                        score += 10;
                        scoreEl.innerText = score;

                        // 掉落道具
                        if(b.type === "longPaddle") {
                            powerUps.push({x: b.x + brickWidth/2, y: b.y, dy: 2});
                        }

                        if(score >= brickColumnCount * brickRowCount * 10 * level) {
                            level++;
                            levelEl.innerText = level;
                            brickRowCount = Math.min(brickRowCount + 1, 6);
                            initGameValues();
                        }
                    }
                }
            }
        }
    }

    function drawBall() {
        ctx.beginPath();
        ctx.arc(x, y, ballRadius, 0, Math.PI*2);
        ctx.fillStyle = "#00d4ff";
        ctx.fill();
        ctx.shadowBlur = 10;
        ctx.shadowColor = "#00d4ff";
        ctx.closePath();
    }

    function drawPaddle() {
        ctx.beginPath();
        ctx.roundRect(paddleX, canvas.height - paddleHeight, paddleWidth, paddleHeight, 5);
        ctx.fillStyle = "#fff";
        ctx.fill();
        ctx.shadowBlur = 0;
        ctx.closePath();
    }

    function drawBricks() {
        for(let c=0; c<brickColumnCount; c++) {
            for(let r=0; r<brickRowCount; r++) {
                if(bricks[c][r].status === 1) {
                    let bX = (c*(brickWidth+brickPadding)) + brickOffsetLeft;
                    let bY = (r*(brickHeight+brickPadding)) + brickOffsetTop;
                    bricks[c][r].x = bX;
                    bricks[c][r].y = bY;
                    ctx.beginPath();
                    ctx.roundRect(bX, bY, brickWidth, brickHeight, 3);
                    ctx.fillStyle = bricks[c][r].type === "longPaddle" ? "#e94560" : `hsl(${200 + (r*20)}, 100%, 50%)`;
                    ctx.fill();
                    ctx.closePath();
                }
            }
        }
    }

    function drawPowerUps() {
        powerUps.forEach((p, index) => {
            p.y += p.dy;
            ctx.beginPath();
            ctx.arc(p.x, p.y, 8, 0, Math.PI*2);
            ctx.fillStyle = "#ff2e63";
            ctx.fill();
            ctx.closePath();

            // 道具碰撞檢測
            if(p.y + 8 > canvas.height - paddleHeight && p.x > paddleX && p.x < paddleX + paddleWidth) {
                paddleWidth += 40; // 效果：擋板變長
                powerUps.splice(index, 1);
                setTimeout(() => { paddleWidth = Math.max(100, paddleWidth - 40); }, 8000);
            } else if(p.y > canvas.height) {
                powerUps.splice(index, 1);
            }
        });
    }

    function draw() {
        if(!isRunning) return;
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        drawBricks();
        drawBall();
        drawPaddle();
        drawPowerUps();
        collisionDetection();

        // 牆壁碰撞
        if(x + dx > canvas.width - ballRadius || x + dx < ballRadius) dx = -dx;
        if(y + dy < ballRadius) dy = -dy;
        else if(y + dy > canvas.height - ballRadius) {
            if(x > paddleX && x < paddleX + paddleWidth) {
                // 根據撞擊位置決定反彈角度
                let hitPoint = (x - (paddleX + paddleWidth / 2)) / (paddleWidth / 2);
                dx = hitPoint * 5;
                dy = -dy;
            } else {
                lives--;
                livesEl.innerText = lives;
                if(lives <= 0) {
                    statusTitle.innerText = "遊戲結束";
                    overlay.classList.remove("hidden");
                    isRunning = false;
                } else {
                    x = canvas.width / 2;
                    y = canvas.height - 30;
                    dx = 4 + level;
                    dy = -(4 + level);
                }
            }
        }

        x += dx;
        y += dy;
        requestAnimationFrame(draw);
    }
</script>

</body>
</html>
